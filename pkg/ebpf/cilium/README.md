## cilium-ebpf

### 静态编译和链接bpf2go

```zsh
export CILIUM_EBPF=${GOPATH}/src/github.com/cilium/ebpf
cd ${CILIUM_EBPF}
CC=clang CGO_ENABLED=1                                           \
go build -gcflags "all=-N -l"                                    \
 -a -ldflags '-linkmode external -extldflags "-fno-PIC -static"' \
 -o ${GOPATH}/bin/bpf2go ${CILIUM_EBPF}/cmd/bpf2go
# ============================================================================
# github.com/cilium/ebpf/cmd/bpf2go
loadinternal: cannot find runtime/cgo
$ ls -lrt $GOPATH/bin
-rwxr-xr-x 1 root root  6029688 6月  15 09:56 bpf2go
# ============================================================================
# http://peerxu.github.io/2018/05/10/cross-compile-golang-by-docker-on-macos/
$ go build -o plugin.so -buildmode=plugin plugin/plugin.go
$ go build -o hello main.go
$ ./hello
hello, world
```

### 使用bpf2go生成.o和.go文件

```zsh
export CILIUM_EBPF=${GOPATH}/src/github.com/cilium/ebpf
export PRJ_ROOT=${GOPATH}/src/github.com/jeevan86/learngolang
export PRJ_CILIUM_EBPF_KPROBE=kprobe
export GOPACKAGE=${PRJ_CILIUM_EBPF_KPROBE}
export BPF_CLANG=clang
export BPF_CFLAGS="-I${CILIUM_EBPF}/examples/headers"
cd ${PRJ_ROOT}/pkg/ebpf/cilium/${PRJ_CILIUM_EBPF_KPROBE}
rm -f ./bpf_bpfe*.go ./bpf_bpfe*.o ./bpf_bpfe*.o.d
${GOPATH}/bin/bpf2go -cc ${BPF_CLANG} -cflags ${BPF_CFLAGS} bpf ./kprobe.c \
 -- -I${CILIUM_EBPF}/examples/headers -I/usr/include/linux
```

#### 如何生成.o文件

bpf2go中实际是使用clang命令编译生成.o文件，命令行如下

```zsh
# 1
# -MF/dev/fd/3
clang -O2 -mcpu=v1 -g -fno-ident -MD -MP -MF ./bpf_bpfel.o.d -target bpfel                               \
 -fdebug-prefix-map=/opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe=.      \
 -fdebug-compilation-dir .                                                                               \
 -D__BPF_TARGET_MISSING="GCC error \"The eBPF is using target specific macros, please provide -target\"" \
 -I/opt/golang/gopath/src/github.com/cilium/ebpf/examples/headers                                        \
 -c /opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/kprobe.c               \
 -o /opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/bpf_bpfel.o

# 2
# -MF/dev/fd/3
clang -O2 -mcpu=v1 -g -fno-ident -MD -MP -MF ./bpf_bpfeb.o.d -target bpfeb                               \
 -fdebug-prefix-map=/opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe=.      \
 -fdebug-compilation-dir .                                                                               \
 -D__BPF_TARGET_MISSING="GCC error \"The eBPF is using target specific macros, please provide -target\"" \
 -I/opt/golang/gopath/src/github.com/cilium/ebpf/examples/headers                                        \
 -c /opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/kprobe.c               \
 -o /opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/bpf_bpfeb.o
```

**kprobe.c**

```c
// +build ignore

#include "common.h"

char __license[] SEC("license") = "Dual MIT/GPL";

struct bpf_map_def SEC("maps") kprobe_map = {
	.type        = BPF_MAP_TYPE_ARRAY,
	.key_size    = sizeof(u32),
	.value_size  = sizeof(u64),
	.max_entries = 1,
};

SEC("kprobe/sys_execve")
int kprobe_execve() {
	u32 key     = 0;
	u64 initval = 1, *valp;

	valp = bpf_map_lookup_elem(&kprobe_map, &key);
	if (!valp) {
		bpf_map_update_elem(&kprobe_map, &key, &initval, BPF_ANY);
		return 0;
	}
	__sync_fetch_and_add(valp, 1);

	return 0;
}
```

#### 如何生成.go文件

##### 从.o中读出各种元素
github.com/cilium/ebpf/elf_reader.go:48:LoadCollectionSpecFromReader
##### 生成对应的.go文件
github.com/cilium/ebpf/cmd/bpf2go/output.go:21:commonRaw
**const commonRaw = ...**
```go
// Code generated by bpf2go; DO NOT EDIT.
{{- range .Tags }}
// +build {{ . }}
{{- end }}

package {{ .Package }}

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"{{ .Module }}"
)

{{- if .Types }}
{{- range $type := .Types }}
{{ $.TypeDeclaration (index $.TypeNames $type) $type }}

{{ end }}
{{- end }}

// {{ .Name.Load }} returns the embedded CollectionSpec for {{ .Name }}.
func {{ .Name.Load }}() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader({{ .Name.Bytes }})
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load {{ .Name }}: %w", err)
	}

	return spec, err
}

// {{ .Name.LoadObjects }} loads {{ .Name }} and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//     *{{ .Name.Objects }}
//     *{{ .Name.Programs }}
//     *{{ .Name.Maps }}
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func {{ .Name.LoadObjects }}(obj interface{}, opts *ebpf.CollectionOptions) (error) {
	spec, err := {{ .Name.Load }}()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// {{ .Name.Specs }} contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.Specs }} struct {
	{{ .Name.ProgramSpecs }}
	{{ .Name.MapSpecs }}
}

// {{ .Name.Specs }} contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.ProgramSpecs }} struct {
{{- range $name, $id := .Programs }}
	{{ $id }} *ebpf.ProgramSpec {{ tag $name }}
{{- end }}
}

// {{ .Name.MapSpecs }} contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type {{ .Name.MapSpecs }} struct {
{{- range $name, $id := .Maps }}
	{{ $id }} *ebpf.MapSpec {{ tag $name }}
{{- end }}
}

// {{ .Name.Objects }} contains all objects after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Objects }} struct {
	{{ .Name.Programs }}
	{{ .Name.Maps }}
}

func (o *{{ .Name.Objects }}) Close() error {
	return {{ .Name.CloseHelper }}(
		&o.{{ .Name.Programs }},
		&o.{{ .Name.Maps }},
	)
}

// {{ .Name.Maps }} contains all maps after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Maps }} struct {
{{- range $name, $id := .Maps }}
	{{ $id }} *ebpf.Map {{ tag $name }}
{{- end }}
}

func (m *{{ .Name.Maps }}) Close() error {
	return {{ .Name.CloseHelper }}(
{{- range $id := .Maps }}
		m.{{ $id }},
{{- end }}
	)
}

// {{ .Name.Programs }} contains all programs after they have been loaded into the kernel.
//
// It can be passed to {{ .Name.LoadObjects }} or ebpf.CollectionSpec.LoadAndAssign.
type {{ .Name.Programs }} struct {
{{- range $name, $id := .Programs }}
	{{ $id }} *ebpf.Program {{ tag $name }}
{{- end }}
}

func (p *{{ .Name.Programs }}) Close() error {
	return {{ .Name.CloseHelper }}(
{{- range $id := .Programs }}
		p.{{ $id }},
{{- end }}
	)
}

func {{ .Name.CloseHelper }}(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//go:embed {{ .File }}
var {{ .Name.Bytes }} []byte
```
**生成好的.go文件**
```go
// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64
// +build 386 amd64 amd64p32 arm arm64 mips64le mips64p32le mipsle ppc64le riscv64

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadBpf returns the embedded CollectionSpec for bpf.
func loadBpf() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_BpfBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load bpf: %w", err)
	}

	return spec, err
}

// loadBpfObjects loads bpf and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//     *bpfObjects
//     *bpfPrograms
//     *bpfMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadBpfObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadBpf()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// bpfSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfSpecs struct {
	bpfProgramSpecs
	bpfMapSpecs
}

// bpfSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfProgramSpecs struct {
	KprobeExecve *ebpf.ProgramSpec `ebpf:"kprobe_execve"`
}

// bpfMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type bpfMapSpecs struct {
	KprobeMap *ebpf.MapSpec `ebpf:"kprobe_map"`
}

// bpfObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfObjects struct {
	bpfPrograms
	bpfMaps
}

func (o *bpfObjects) Close() error {
	return _BpfClose(
		&o.bpfPrograms,
		&o.bpfMaps,
	)
}

// bpfMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfMaps struct {
	KprobeMap *ebpf.Map `ebpf:"kprobe_map"`
}

func (m *bpfMaps) Close() error {
	return _BpfClose(
		m.KprobeMap,
	)
}

// bpfPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
type bpfPrograms struct {
	KprobeExecve *ebpf.Program `ebpf:"kprobe_execve"`
}

func (p *bpfPrograms) Close() error {
	return _BpfClose(
		p.KprobeExecve,
	)
}

func _BpfClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//go:embed bpf_bpfel.o
var _BpfBytes []byte
```

### 使用bpf_bpfe*.go

#### 模块kprobe.go

```go
//go:build linux
// +build linux

// Package kprobe
// This program demonstrates attaching an eBPF program to a kernel symbol.
// The eBPF program will be attached to the start of the sys_execve
// kernel function and prints out the number of times it has been called
// every second.
package kprobe

import (
	"github.com/cilium/ebpf/link"
	"github.com/jeevan86/learngolang/pkg/log"
)

// $BPF_CLANG and $BPF_CFLAGS are set by the Makefile.
//go:generate ${GOPATH}/bin/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS bpf kprobe.c -- -I../headers

var logger = log.NewLogger()

const mapKey uint32 = 0

type KpSysExecve struct {
	fn   string
	objs bpfObjects // Load pre-compiled programs and maps into the kernel.
	kp   link.Link
}

func NewKpSysExecve() *KpSysExecve {
	return &KpSysExecve{
		fn:   "sys_execve", // Name of the kernel function to trace.
		objs: bpfObjects{},
	}
}

func (k *KpSysExecve) GetName() string {
	return k.fn
}

func (k *KpSysExecve) Load() error {
	err := loadBpfObjects(&k.objs, nil)
	if err != nil {
		logger.Fatal("loading objects: %v", err)
		return err
	}
	// Open a Kprobe at the entry point of the kernel function and attach the
	// pre-compiled program. Each time the kernel function enters, the program
	// will increment the execution counter by 1. The read loop below polls this
	// map value once per second.
	k.kp, err = link.Kprobe(k.fn, k.objs.KprobeExecve, nil)
	if err != nil {
		logger.Fatal("opening kprobe: %s", err)
		return err
	}
	return nil
}

func (k *KpSysExecve) Close() {
	defer func() {
		_ = k.objs.Close()
	}()
	_ = k.kp.Close()
}

func (k *KpSysExecve) Lookup(ptr interface{}) error {
	return k.objs.KprobeMap.Lookup(mapKey, ptr)
}
```

#### 调度cilium.go

```go
package cilium

import (
	"github.com/cilium/ebpf/rlimit"
	"github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe"
	"github.com/jeevan86/learngolang/pkg/log"
	"os"
	"time"
)

var logger = log.NewLogger()

func Start() {
	// Allow the current process to lock memory for eBPF resources.
	if err := rlimit.RemoveMemlock(); err != nil {
		logger.Fatal("%v", err)
		os.Exit(-1)
	}

	k := kprobe.NewKpSysExecve()

	defer k.Close()

	err := k.Load()
	if err != nil {
		return
	}

	// Read loop reporting the total amount of times the kernel
	// function was entered, once per second.
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	logger.Info("Waiting for events..")
	for range ticker.C {
		var value uint64
		if err := k.Lookup(&value); err != nil {
			logger.Fatal("reading map: %v", err)
		}
		logger.Info("%s called %d times.", k.GetName(), value)
	}
}
```

```zsh
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/bpf*.go pkg/ebpf/cilium/kprobe/
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/kprobe/bpf*.o pkg/ebpf/cilium/kprobe/
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/tcptracer/bpf*.go pkg/ebpf/cilium/tcptracer/
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/tcptracer/bpf*.o pkg/ebpf/cilium/tcptracer/
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/tracepoint/bpf*.go pkg/ebpf/cilium/tracepoint/
scp root@192.168.7.86:/data/volumes/jeevan-go/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/tracepoint/bpf*.o pkg/ebpf/cilium/tracepoint/
```

### 构建命令行

```zsh
export PRJ_ROOT=${GOPATH}/src/github.com/jeevan86/learngolang
go build -o ${GOPATH}/bin/ebpf_cilium ${PRJ_ROOT}/cmd/ebpf/cilium/main.go
```

### 内核支持
从```http://mirrors.aliyun.com/elrepo/kernel/el7/x86_64/RPMS/```下载
```
elrepo-release-7.0-4.el7.elrepo.noarch.rpm
kernel-lt-4.4.249-1.el7.elrepo.x86_64.rpm
kernel-lt-devel-4.4.249-1.el7.elrepo.x86_64.rpm
kernel-lt-doc-4.4.249-1.el7.elrepo.noarch.rpm
kernel-lt-headers-4.4.249-1.el7.elrepo.x86_64.rpm
kernel-lt-tools-4.4.249-1.el7.elrepo.x86_64.rpm
kernel-lt-tools-libs-4.4.249-1.el7.elrepo.x86_64.rpm
kernel-lt-tools-libs-devel-4.4.249-1.el7.elrepo.x86_64.rpm
perf-4.4.249-1.el7.elrepo.x86_64.rpm
python-perf-4.4.249-1.el7.elrepo.x86_64.rpm
```
```zsh
# 安装kernel-lt-4.4.249-1.el7.elrepo.x86_64.rpm即可
cd /opt/rpms/kernel/4.4.249
yum localinstall kernel-lt-4.4.249-1.el7.elrepo.x86_64.rpm
cd /boot
awk -F\' '$1=="menuentry " {print i++ " : " $2}' /etc/grub2.cfg
grub2-set-default 0
grub2-editenv list
uname -an
reboot
uname -r
```

```zsh
# make headers_install_all INSTALL_HDR_PATH=../linux-4.18-headers
# make headers_install_all INSTALL_HDR_PATH=../linux-4.18-headers ARCH=x86

rm -rf /data/linux-4.18-headers
rm -rf ${GOPATH}/src/linux/4.18
make CC=clang HOSTCC=clang defconfig
export CC=clang
export HOSTCC=clang
make CC=clang HOSTCC=clang -no-integrated-as headers_install INSTALL_HDR_PATH=/data/linux-4.18-headers

mkdir -p ${GOPATH}/src/linux/4.18/headers
mkdir -p ${GOPATH}/src/linux/4.18/headers/asm
mkdir -p ${GOPATH}/src/linux/4.18/headers/net
mkdir -p ${GOPATH}/src/linux/4.18/headers/uapi
mkdir -p ${GOPATH}/src/linux/4.18/headers/uapi/asm
mkdir -p ${GOPATH}/src/linux/4.18/tools
# common
cp -rf /data/linux-4.18-headers/include/*                           ${GOPATH}/src/linux/4.18/headers/
# common/linux
cp -rf /data/linux-4.18/include/linux/*.h                           ${GOPATH}/src/linux/4.18/headers/linux/
# common/asm
cp -rf /data/linux-4.18/arch/x86/include/asm/*.h                    ${GOPATH}/src/linux/4.18/headers/asm/
cp -rf /data/linux-4.18/include/asm-generic/*.h                     ${GOPATH}/src/linux/4.18/headers/asm-generic/
# common/net
cp -rf /data/linux-4.18/include/net/*                               ${GOPATH}/src/linux/4.18/headers/net/
# common/uapi
cp -rf /data/linux-4.18/include/uapi/*                              ${GOPATH}/src/linux/4.18/headers/uapi/
cp -rf /data/linux-4.18/arch/x86/include/uapi/asm/*.h               ${GOPATH}/src/linux/4.18/headers/uapi/asm/

# tools
cp -rf /data/linux-4.18/tools/include/*                         ${GOPATH}/src/linux/4.18/tools/

cp -rf /data/linux-4.18/include/generated/uapi/linux/version.h  ${GOPATH}/src/linux/4.18/headers/uapi/linux/

cp -rf /data/linux-4.18/include/linux/stringify.h               ${GOPATH}/src/linux/4.18/headers/uapi/linux/
cp -rf /data/linux-4.18/include/linux/linkage.h                 ${GOPATH}/src/linux/4.18/headers/uapi/linux/
cp -rf /data/linux-4.18/include/linux/export.h                  ${GOPATH}/src/linux/4.18/headers/uapi/linux/
cp -rf /data/linux-4.18/include/linux/mem_encrypt.h             ${GOPATH}/src/linux/4.18/headers/uapi/linux/
cp -rf /data/linux-4.18/include/linux/compiler*.h               ${GOPATH}/src/linux/4.18/headers/uapi/linux/
cp -rf /data/linux-4.18/arch/x86/include/asm/bitops.h           ${GOPATH}/src/linux/4.18/headers/uapi/linux/

cp /data/linux-4.18/include/linux/stddef.h                      $GOPATH/src/linux/4.18/headers/linux/


#cp /data/linux-4.18/include/generated/uapi/linux/version.h      ${GOPATH}/src/linux/4.18/headers/linux/

##     
cp /data/linux-4.18/include/linux/atomic.h                      ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/compiler*.h                   ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/jhash.h                       ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/bitops.h                      ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/stringify.h                   ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/build_bug.h                   ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/kasan-checks.h                ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/timer.h                       ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/ktime.h                       ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/time.h                        ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/cache.h                       ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/netdevice.h                   ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/unaligned -r                  ${GOPATH}/src/linux/4.18/headers/linux/
cp /data/linux-4.18/include/linux/*.h                           ${GOPATH}/src/linux/4.18/headers/linux/

cp $GOPATH/src/linux/4.18/headers/uapi/linux/sysinfo.h          ${GOPATH}/src/linux/4.18/headers/linux/
cp $GOPATH/src/linux/4.18/headers/uapi/linux/posix_types.h      ${GOPATH}/src/linux/4.18/headers/linux/
##     
cp /data/linux-4.18/arch/x86/include/asm/alternative.h          ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/asm.h                  ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/atomic.h               ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/bitops.h               ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/rmwcc.h                ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/barrier.h              ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/nops.h                 ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/processor-flags.h      ${GOPATH}/src/linux/4.18/headers/asm/
cp /data/linux-4.18/arch/x86/include/asm/*.h                    ${GOPATH}/src/linux/4.18/headers/asm/
##     
cp /data/linux-4.18/include/asm-generic/bitops.h                ${GOPATH}/src/linux/4.18/headers/asm-generic/
cp /data/linux-4.18/include/asm-generic/bitops -r               ${GOPATH}/src/linux/4.18/headers/asm-generic/
cp /data/linux-4.18/include/asm-generic/barrier.h               ${GOPATH}/src/linux/4.18/headers/asm-generic/
cp /data/linux-4.18/include/asm-generic/*.h                     ${GOPATH}/src/linux/4.18/headers/asm-generic/
##      
cp /data/linux-4.18/arch/x86/include/uapi/asm/processor-flags.h ${GOPATH}/src/linux/4.18/headers/uapi/asm/

```

```c
// https://zhuanlan.zhihu.com/p/39869242
// https://blog.csdn.net/weibo1230123/article/details/84106028
#define __packed

typedef struct {
        int counter;
} atomic_t;

typedef struct {
        long counter;
} atomic64_t;

// clang -DBITS_PER_LONG=64
```

```makefile
...
In file included from /opt/golang/gopath/src/github.com/jeevan86/learngolang/pkg/ebpf/cilium/tcptracer/c/tcptracer.c:33:
In file included from /opt/golang/gopath/src/linux/current/headers/net/inet_sock.h:25:
In file included from /opt/golang/gopath/src/linux/current/headers/net/flow.h:13:
In file included from /opt/golang/gopath/src/linux/current/headers/linux/atomic.h:5:
In file included from /opt/golang/gopath/src/linux/current/headers/asm/atomic.h:280:
/opt/golang/gopath/src/linux/current/headers/asm/atomic64_64.h:177:9: error: invalid output constraint '=a' in asm
/opt/golang/gopath/src/linux/current/headers/asm/cmpxchg.h:149:2: note: expanded from macro 'arch_cmpxchg'
        __cmpxchg(ptr, old, new, sizeof(*(ptr)))
        ^
/opt/golang/gopath/src/linux/current/headers/asm/cmpxchg.h:134:2: note: expanded from macro '__cmpxchg'
        __raw_cmpxchg((ptr), (old), (new), (size), LOCK_PREFIX)
        ^
/opt/golang/gopath/src/linux/current/headers/asm/cmpxchg.h:122:11: note: expanded from macro '__raw_cmpxchg'
                             : "=a" (__ret), "+m" (*__ptr)

https://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1546605.html
https://lore.kernel.org/netdev/20220414134134.247912-1-yangjihong1@huawei.com/T/
https://github.com/torvalds/linux/blob/master/tools/perf/Documentation/perf-config.txt
...
	llvm.clang-bpf-cmd-template::
		Cmdline template. Below lines show its default value. Environment
		variable is used to pass options.
		"$CLANG_EXEC -D__KERNEL__ -D__NR_CPUS__=$NR_CPUS "\
		"-DLINUX_VERSION_CODE=$LINUX_VERSION_CODE "	\
		"$CLANG_OPTIONS $PERF_BPF_INC_OPTIONS $KERNEL_INC_OPTIONS " \
		"-Wno-unused-value -Wno-pointer-sign "		\
		"-working-directory $WORKING_DIR "		\
		"-c \"$CLANG_SOURCE\" -target bpf $CLANG_EMIT_LLVM -O2 -o - $LLVM_OPTIONS_PIPE"
...		
```

```
http://mirrors.coreix.net/elrepo-archive-archive/kernel/el7/x86_64/RPMS/
kernel-ml-4.18.16-1.el7.elrepo.x86_64.rpm
kernel-ml-devel-4.18.16-1.el7.elrepo.x86_64.rpm
```

```go
2022-06-21 11:23:07.566	fatal	cilium/cilium.go:21	loading objects: field KprobeAccept: program kprobe_accept: load program without BTF: invalid argument: unrecognized bpf_ld_imm64 insn

include/uapi/linux/bpf.h:BPF_PSEUDO_MAP_FD
kernel/bpf/verifier.c:
if (insn->src_reg != BPF_PSEUDO_MAP_FD) {
verbose(env,
"unrecognized bpf_ld_imm64 insn\n");
return -EINVAL;
}
```